import numpy as np
import pandas as pd

class ratesBinomial():
    '''
    attributute:

    q = float. Risk neutral probability.
    
    r0: float. Initial rate of binomial tree at time 0.

    u: float. Up parameter in a binomial tree pricing model.

    d: float. Down parameter in a binomial tree pricing model.

    n: int. Length of the tree (excluding the root).

    rates_paths: generated rates paths : np array : [n+1, n+1]
        r0  , r0*d   , r0*(d^2)   , ... , r0*d^n
        0   , r0*u   , r0*u*d     , ... , r0*u*(d^{n-1})
        0   , 0      , r0*(u^2)   , ... , r0*u^2*(d^{n-2})
        ...
        0   , 0      , 0          , ... , r0*(u^n)

    ele_prices: generated elementary prices paths : np array : [n+1, n+1]
        (p_{i,j} = price of a security that pays $1 at state i (i-th time rates up) and time j) 

    yield_curve: np array : n+1:
        the yield curve generated by the binomial rates model:
        [time 1 ZCB rate, time 2 ZCB rate, ... ]
    '''
     
    def __init__(self, q = 0.5, r0 = 0.2, u = 1.25, d = 0.8, n = 5) -> None:
        self.q = q
        self.r0 = r0
        self.u = u
        self.d = d 
        self.n = n
        self.tree = None
        self.ele_prices = None
        self.yield_curve = None
        self.final_payOff = None

    def generate_rates_paths(self):
        '''
        returns:
            generated rates paths : np.array : [n+1, n+1]
            r0  , r0*d   , r0*(d^2)   , ... , r0*d^n
            0   , r0*u   , r0*u*d     , ... , r0*u*(d^{n-1})
            0   , 0      , r0*(u^2)   , ... , r0*u^2*(d^{n-2})
            ...
            0   , 0      , 0          , ... , r0*(u^n)
        '''
        res = np.ones([self.n+1,self.n+1])

        # fill diagonal with [r0, r0*u, r0* u^2, ...]
        ups = np.ones(self.n+1) * self.r0
        ups[1:] = self.u
        ups = np.cumprod(ups)
        np.fill_diagonal(res,ups)

        # Each row i has non empty entries: [r0* u^i, r0* u^i * d, r0* u^i *d^2, ...]
        for n_ups in range(self.n+1):
            res[n_ups,n_ups+1:] = self.d
            res[n_ups] = np.cumprod(res[n_ups])
        self.rates_paths = np.triu(res)

    def generate_elementary_prices(self):
        if self.rates_paths is None:
            self.generate_rates_paths()
        res = np.zeros([self.n+1, self.n+1])
        
        # forward equation:
        # p_{i,j} = (1-q) * p_{i,j-1} / (1+r_{i,j-1}) + q * p_{i-1,j-1} / (1+r_{i-1,j-1})
        res[0,0] = 1
        for c in range(1,res.shape[1]):
            for r in range(c+1):
                if r == 0:
                    res[r,c] = (1-self.q) * res[r,c-1] / (1+self.rates_paths[r,c-1])
                else:
                    res[r,c] = (1-self.q) * res[r,c-1] / (1+self.rates_paths[r,c-1]) + self.q * res[r-1,c-1] / (1+self.rates_paths[r-1,c-1])
        self.ele_prices = res

    def generate_yield_curve(self):
        if self.rates_paths is None:
            self.generate_rates_paths()
        if self.ele_prices is None:
            self.generate_elementary_prices()
        self.yield_curve =  np.array([0] + [np.power(1/np.sum(self.ele_prices[:,t]) , 1/t) - 1 for t in range(1,self.n + 1)])

class binomialPricing():
    '''
    attributute:

    rates_model: ratesBinomial model.

    T: int. Maturity.

    coupon_rate: float. coupon rate of product.

    q: float. Risk neutral probability.

    final_payOff: the final payoff at t of the product.

    Pricing_tree: np array: [n+1, n+1]
        (P_{i,j}) : the binomial tree of prduct price P_{i,j} at state i time j.
        
    '''
    def __init__(self, rates_model : ratesBinomial, T = 4, coupon_rate = 0.03, q = 0.5) -> None:
        self.rates_model = rates_model
        if T <= rates_model.n:
            self.T = T
        else:
            raise AttributeError("Please ensure T is less or equal than n in rates_model.")
        self.final_payOff = None
        self.coupon_rate = coupon_rate
        self.q = q
        self.Pricing_tree = None
    
    def set_finalPayoff(self,final_payOff):
        '''
        final_payOff : np.array: n+1:
            [state 0 payoff, state 1 payoff, ..., state n payoff]
        '''
        if final_payOff is not None:
            if self.T != len(final_payOff) - 1:
                raise IndexError("Please ensure the length of final_payOff is T + 1.")
        self.final_payOff = final_payOff

    def binomial_pricing(self, if_american = False, immediate_payOff = None):
        if self.rates_model.rates_paths is None:
            self.rates_model.generate_rates_paths()
        if self.final_payOff is None:
            raise AttributeError("Please ensure set_finalPayoff(final_payOff) has been run before calling pricing() function.")
        res = np.zeros([self.T + 1,self.T + 1])
        res[:,-1] = self.final_payOff
        for c in range(res.shape[0]-2,-1,-1):
            for r in range(c+1):
                    res[r,c] = self.coupon_rate * self.F + (self.q * res[r + 1, c + 1] + (1 - self.q) * res[r, c + 1]) / (1 + self.rates_model.rates_paths[r,c])
                    if if_american == True:
                        res[r,c] = max(res[r,c],immediate_payOff[r,c])
        self.Pricing_tree = res
        return res[0,0]
    
    def swap_binomial_pricing(self, Swap_T0, Swap_K):
        if self.rates_model.rates_paths is None:
            self.rates_model.generate_rates_paths()
        if self.final_payOff is None:
            raise AttributeError("Please ensure set_finalPayoff(final_payOff) has been run before calling pricing() function.")
        res = np.zeros([self.T + 1,self.T + 1])
        res[:,-1] = self.final_payOff
        for c in range(res.shape[0]-2,-1,-1):
            for r in range(c+1):
                    if c >= Swap_T0:
                        cur_payoff = self.rates_model.rates_paths[r,c] - Swap_K
                    else:
                        cur_payoff = 0
                    res[r,c] = (cur_payoff + self.q * res[r + 1, c + 1] + (1 - self.q) * res[r, c + 1]) / (1 + self.rates_model.rates_paths[r,c])
        self.Pricing_tree = res
        return res[0,0]
                    
class bondModel(binomialPricing):
    '''
    attributute:

    T: int. Maturity.

    coupon_rate: float.

    q: float. Risk-neutral probability.

    F = float. Face value.
    '''
    def __init__(self, rates_model : ratesBinomial, T = 4, coupon_rate = 0.03, q = 0.5, F = 100) -> None:
        super(bondModel,self).__init__(rates_model, T, coupon_rate, q)
        self.F = F

    def pricing(self):
        self.set_finalPayoff(np.ones(self.T + 1)*self.F + self.coupon_rate * self.F)
        return self.binomial_pricing()
    
class bondForwardModel(binomialPricing):
    '''
    attributute:

    bond_T: int. Maturity of bond.

    coupon_rate: float.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Forward_T : int. Maturity of forward.
    '''
    def __init__(self, rates_model : ratesBinomial, bond_T = 4, coupon_rate = 0.03, q = 0.5, F = 100, Forward_T = 3) -> None:
        super(bondForwardModel,self).__init__(rates_model, bond_T, coupon_rate, q)
        self.F = F
        self.Forward_T = Forward_T

    def pricing(self):
        self.set_finalPayoff(np.ones(self.T + 1)*self.F + self.coupon_rate * self.F)
        self.binomial_pricing()
        forward_payOff = self.Pricing_tree[:self.Forward_T+1,self.Forward_T] - self.coupon_rate * self.F          # forward does not pay coupon

        self.coupon_rate = 0.0                                    # forward does not pay coupon
        self.T = self.Forward_T                                   # Now we are just discouting the ZCB maturing at Forward_T
        self.set_finalPayoff(forward_payOff)

        if self.rates_model.yield_curve is None:
            self.rates_model.generate_yield_curve()
        return self.binomial_pricing() * np.power((self.rates_model.yield_curve[self.Forward_T] + 1), self.Forward_T)
    
class bondFuturesModel(binomialPricing):
    '''
    attributute:

    bond_T: int. Maturity of bond.

    coupon_rate: float.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Futures_T : int. Maturity of futures.
    '''
    def __init__(self, rates_model : ratesBinomial, bond_T = 4, coupon_rate = 0.03, q = 0.5, F = 100, Futures_T = 3) -> None:
        super(bondFuturesModel,self).__init__(rates_model, bond_T, coupon_rate, q)
        self.F = F
        self.Futures_T = Futures_T

    def pricing(self):
        self.set_finalPayoff(np.ones(self.T + 1)*self.F + self.coupon_rate * self.F)
        self.binomial_pricing()
        Futures_payOff = self.Pricing_tree[:self.Futures_T+1,self.Futures_T] - self.coupon_rate * self.F          # forward does not pay coupon

        self.coupon_rate = 0.0                                                                                        # forward does not pay coupon
        rates_model = ratesBinomial(q = self.rates_model.q, r0 = 0, u = 0, d = 0, n = self.Futures_T)                 # no discounting when calculating futures price = 
                                                                                                                      # E_Q(Z (Futures_T) )
        rates_model.generate_rates_paths()
        self.rates_model = rates_model
        self.T = self.Futures_T                                                                                       # Now we are just discouting the ZCB maturing at Futures_T
        self.set_finalPayoff(Futures_payOff)

        return self.binomial_pricing()
    
class bondOptionsModel(binomialPricing):
    '''
    attributute:

    F : float. Face value.

    bond_T: int. Maturity of bond.

    coupon_rate: float.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Options_T : int. Maturity of the option.

    Options_K: float. Strike price of the option.

    CallOrPut: string. 
        Options: 'call', 'put'

    if_american: bool. If the option is an American.
    '''
    def __init__(self, rates_model : ratesBinomial, bond_T = 4, coupon_rate = 0.03, q = 0.5, F = 100, 
                 Options_T = 3, Options_K = 100, CallOrPut = 'call', if_american = True) -> None:
        super(bondOptionsModel,self).__init__(rates_model, bond_T, coupon_rate, q)
        self.F = F
        self.Options_T = Options_T
        self.Options_K = Options_K
        self.CallOrPut = CallOrPut
        self.if_american = if_american

    def pricing(self):

        # find out bond pricing tree
        self.set_finalPayoff(np.ones(self.T + 1)*self.F + self.coupon_rate * self.F)
        self.binomial_pricing()

        # set up time T pay off of option
        self.Pricing_tree = self.Pricing_tree[:self.Options_T+1,:self.Options_T+1]
        if self.CallOrPut == 'call':
            Options_payOff = np.maximum(self.Pricing_tree[:self.Options_T+1,self.Options_T] 
                                    - self.coupon_rate * self.F - self.Options_K, np.zeros(self.Options_T+1))
        else:
            Options_payOff = np.maximum(self.Options_K - (self.Pricing_tree[:self.Options_T+1,self.Options_T] 
                                    - self.coupon_rate * self.F), np.zeros(self.Options_T+1))
            
        # get pricing of options
        self.T = self.Options_T
        self.set_finalPayoff(Options_payOff)   
        if self.if_american:
            if self.CallOrPut == 'call':
                immediate_payOff = np.triu(self.Pricing_tree - self.Options_K)
            else:
                immediate_payOff = np.triu(self.Options_K - self.Pricing_tree)
        else:
            immediate_payOff = None
        return self.binomial_pricing(if_american = self.if_american, immediate_payOff = immediate_payOff)
    
class CapletFloorletModel(binomialPricing):
    '''
    attributute:

    F : float. Face value.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Options_T : int. Maturity of the option.

    Options_K: float. Strike rate of the option.

    CapletOrFloorlet: string. 
        Options: 'caplet', 'floorlet'

    if_american: bool. If the option is an American.
    '''
    def __init__(self, rates_model : ratesBinomial, q = 0.5, F = 100, 
                 Options_T = 3, Options_K = 0.02, CapletOrFloorlet = 'caplet', if_american = False) -> None:
        super(CapletFloorletModel,self).__init__(rates_model, T = Options_T, coupon_rate = 0.0, q = q)
        self.F = F
        self.Options_T = Options_T
        self.Options_K = Options_K
        self.CapletOrFloorlet = CapletOrFloorlet
        self.if_american = if_american

    def pricing(self):

        # set up time T pay off of option
        self.rates_modelrates_paths = self.rates_model.rates_paths[:self.Options_T+1,:self.Options_T+1]
        if self.CapletOrFloorlet == 'caplet':
            Options_payOff = np.maximum((self.rates_model.rates_paths[:self.Options_T+1,self.Options_T] - self.Options_K) 
                                        / (1 + self.rates_model.rates_paths[:self.Options_T+1,self.Options_T]), 
                                    np.zeros(self.Options_T+1))
        else:
            Options_payOff = np.maximum((self.Options_K - self.rates_modelrates_paths[:self.Options_T+1, self.Options_T])
                                        / (1 + self.rates_model.rates_paths[:self.Options_T+1,self.Options_T]), 
                                    np.zeros(self.Options_T+1))
            
        # get pricing of options
        self.T = self.Options_T
        self.set_finalPayoff(Options_payOff)   
        if self.if_american:
            if self.CallOrPut == 'caplet':
                immediate_payOff = np.triu(self.rates_model.rates_paths - self.Options_K) / (1 + self.rates_model.rates_paths)
            else:
                immediate_payOff = np.triu(self.Options_K - self.rates_model.rates_paths) / (1 + self.rates_model.rates_paths)
        else:
            immediate_payOff = None
        return self.binomial_pricing(if_american = self.if_american, immediate_payOff = immediate_payOff) * self.F
    
class SwapModel(binomialPricing):
    '''
    attributute:

    F : float. Face value.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Swap_T0 : int. Start time of the swap.

    Swap_T : int. End time of the swap.

    Swap_K: float. Fixed out leg of the swap.
    '''
    def __init__(self, rates_model : ratesBinomial, q = 0.5, F = 100, 
                 Swap_T0 = 0, Swap_T = 3, Swap_K = 0.02) -> None:
        super(SwapModel,self).__init__(rates_model, T = Swap_T, coupon_rate = 0.0, q = q)
        self.F = F
        self.Swap_T0 = Swap_T0
        self.Swap_T = Swap_T
        self.Swap_K = Swap_K

    def pricing(self):

        # set up time T pay off of option
        self.rates_modelrates_paths = self.rates_model.rates_paths[:self.Swap_T+1,:self.Swap_T+1]
        Swap_payOff = (self.rates_model.rates_paths[:self.Swap_T+1,self.Swap_T] - self.Swap_K) / (1 + self.rates_model.rates_paths[:self.Swap_T+1,self.Swap_T])
            
        # get pricing of Swap
        self.T = self.Swap_T        
        self.set_finalPayoff(Swap_payOff)
        return self.swap_binomial_pricing(self.Swap_T0, self.Swap_K) * self.F
    

class SwaptionModel(binomialPricing):
    '''
    attributute:

    F : float. Face value.

    q: float. Risk-neutral probability.

    F : float. Face value.

    Swap_T0 : int. Start time of the swap.

    Swap_T : int. Maturity of the option.

    Swap_K: float. Strike rate of the option.

    Options_T : int. Maturity of the option.

    Options_K: float. Strike rate of the option.

    CallOrPut: string. 
        Options: 'call', 'put'

    if_american: bool. If the option is an American.

    '''
    def __init__(self, rates_model : ratesBinomial, q = 0.5, F = 100, Swap_T0 = 0, Swap_T = 3, Swap_K = 0.02,
                 Options_T = 3, Options_K = 0.0, CallOrPut = 'call', if_american = False) -> None:
        super(SwaptionModel,self).__init__(rates_model, T = Swap_T, coupon_rate = 0.0, q = q)
        self.F = F
        self.Swap_T0 = Swap_T0
        self.Swap_T = Swap_T
        self.Swap_K = Swap_K
        self.Options_T = Options_T
        self.Options_K = Options_K
        self.CallOrPut = CallOrPut
        self.if_american = if_american
        self.SwapPricingTree = None

    def pricing(self):

        # set up time T pay off of option
        self.rates_modelrates_paths = self.rates_model.rates_paths[:self.Swap_T+1,:self.Swap_T+1]
        Swap_payOff = (self.rates_model.rates_paths[:self.Swap_T+1,self.Swap_T] - self.Swap_K) / (1 + self.rates_model.rates_paths[:self.Swap_T+1,self.Swap_T])
            
        # get pricing of Swap
        self.T = self.Swap_T        
        self.set_finalPayoff(Swap_payOff)
        self.swap_binomial_pricing(self.Swap_T0, self.Swap_K)
        self.SwapPricingTree = self.Pricing_tree

        # set up time T payoff of option
        if self.CallOrPut == 'call':
            Options_payOff = np.maximum((self.SwapPricingTree[:self.Options_T+1,self.Options_T] - self.Options_K) , 
                                    np.zeros(self.Options_T+1))
        else:
            Options_payOff = np.maximum((self.Options_K - self.rates_modelrates_paths[:self.Options_T+1, self.Options_T]), 
                                    np.zeros(self.Options_T+1))
            
        # get pricing of options
        self.T = self.Options_T
        self.set_finalPayoff(Options_payOff)   
        if self.if_american:
            if self.CallOrPut == 'call':
                immediate_payOff = np.triu(self.SwapPricingTree - self.Options_K)
            else:
                immediate_payOff = np.triu(self.Options_K - self.SwapPricingTree) 
        else:
            immediate_payOff = None
        return self.binomial_pricing(if_american = self.if_american, immediate_payOff = immediate_payOff) * self.F 